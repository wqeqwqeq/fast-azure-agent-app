# Agent Factory Onboarding Skill

When the user runs `/onboard`, follow this process to create a new agent application configuration.

## Overview

This skill helps users create a multi-agent application by:
1. Interactively collecting application configuration
2. Generating Python code for the sub-agent configuration
3. Creating sub-agent files with tool stubs
4. Optionally implementing tool logic

## Architecture Note

The Agent Factory separates **AI-generated** vs **framework** code:
- `subagent_config.py` - AI generated by this skill (SUB_AGENTS, DOMAIN_NAME, DOMAIN_DESCRIPTION)
- Orchestration agents - Framework code with `build_prompt()` / `build_schema()` methods

This skill ONLY generates `subagent_config.py` and sub-agent files. The orchestration agents are framework code and should not be modified.

## Phase 1: Collect Configuration

Ask the user these questions sequentially (wait for each answer before proceeding):

### Step 1: Domain Configuration
Ask: "What domain does this assistant serve? Please provide:
1. **Domain name** (e.g., 'HR Assistant', 'IT Support')
2. **Description** (one sentence explaining what the assistant helps with)"

### Step 2: Sub-Agents
For each sub-agent, collect:
1. **key** (snake_case identifier, e.g., `leave`, `payroll`)
2. **name** (display name, e.g., 'leave-agent')
3. **description** (one-line description)
4. **capabilities** (list of things this agent can do)
5. **tools** (list of tool functions with name and description)

Ask: "Now let's define your specialized agents. For each agent, I need:
- **Key**: Unique identifier (snake_case)
- **Name**: Display name
- **Description**: What this agent handles
- **Capabilities**: List of specific things it can do
- **Tools**: Functions it needs (name + what it does)

Please describe your first agent."

Continue asking: "Do you have another agent to add? (yes/no)"

### Step 3: Confirm Configuration
Present a summary of the collected configuration and ask for confirmation:

```
## Configuration Summary

**Domain**: {domain_name} - {domain_description}

**Agents**:
1. **{agent1_key}** ({agent1_name})
   - Description: {description}
   - Capabilities: {capabilities}
   - Tools: {tools}

2. ...

Does this look correct? (yes/no)
```

## Phase 2: Generate Code

After confirmation, generate the following files:

### 1. `app/agent_factory/subagent_config.py`

Generate the sub-agent configuration. This is the ONLY file the AI generates for the orchestration layer:

```python
"""Sub-Agent Configuration for Agent Factory.

Generated by /onboard skill.

This file contains:
- DOMAIN_NAME: Display name for the assistant
- DOMAIN_DESCRIPTION: What the assistant does
- SUB_AGENTS: List of specialized sub-agents

The orchestration agents (triage, plan, review, etc.) are framework code
and should not be modified. They use SubAgentRegistry to read this config.
"""

from .schemas.config import SubAgentConfig, ToolConfig, ToolParameterConfig

# Domain configuration
DOMAIN_NAME = "{domain_name}"
DOMAIN_DESCRIPTION = "{domain_description}"

# Sub-agent definitions
SUB_AGENTS: list[SubAgentConfig] = [
    SubAgentConfig(
        key="{agent_key}",
        name="{agent_name}",
        description="{agent_description}",
        capabilities=[
            "{capability_1}",
            "{capability_2}",
        ],
        tools=[
            ToolConfig(
                name="{tool_name}",
                description="{tool_description}",
                parameters=[
                    ToolParameterConfig(
                        name="{param_name}",
                        type="{param_type}",
                        description="{param_description}",
                        required=True,
                    ),
                ],
            ),
        ],
    ),
    # ... more agents
]
```

### 2. Sub-Agent Files

For each agent, create `app/agent_factory/agents/sub_agents/{key}_agent.py`:

```python
"""{Description} Agent for {domain} operations."""

from dataclasses import dataclass
from typing import Optional

from ...factory import create_agent
from ...model_registry import ModelRegistry
from .tools.{key}_tools import (
    {tool_imports},
)


@dataclass(frozen=True)
class {Key}AgentConfig:
    """Configuration for the {Key} agent."""

    name: str = "{key}-agent"
    description: str = "{description}"
    instructions: str = """You are a {name} that handles {description}.

## Your Capabilities
{capabilities_as_bullets}

## Guidelines
- Provide accurate information based on tool results
- If you cannot fulfill a request, explain why
- Be helpful and professional
"""


CONFIG = {Key}AgentConfig()


def create_{key}_agent(
    registry: Optional[ModelRegistry] = None,
    model_name: Optional[str] = None,
):
    """Create and return the {Key} agent.

    Args:
        registry: ModelRegistry for cloud mode, None for env settings
        model_name: Model to use (only when registry provided)
    """
    return create_agent(
        name=CONFIG.name,
        description=CONFIG.description,
        instructions=CONFIG.instructions,
        registry=registry,
        model_name=model_name,
        tools=[{tool_list}],
    )
```

### 3. Tool Stub Files

For each agent, create `app/agent_factory/agents/sub_agents/tools/{key}_tools.py`:

```python
"""Tools for {key} agent.

TODO: Implement these tool functions with actual business logic.
"""

import json
from typing import Annotated


def {tool_name}(
    {param_name}: Annotated[{param_type}, "{param_description}"],
) -> str:
    \"""{tool_description}

    Args:
        {param_name}: {param_description}

    Returns:
        JSON string with {expected_return_description}
    \"""
    # TODO: Implement this tool
    # Hint: {implementation_hint}
    raise NotImplementedError("{tool_name} not yet implemented")


# Add more tool functions below...
```

## Phase 3: Post-Generation

After generating files, tell the user:

```
## Files Generated

1. `app/agent_factory/subagent_config.py` - Sub-agent configuration (AI generated)
2. `app/agent_factory/agents/sub_agents/{key}_agent.py` - Agent for each sub-agent
3. `app/agent_factory/agents/sub_agents/tools/{key}_tools.py` - Tool stubs

## Architecture

The Agent Factory separates concerns:
- **AI Generated** (`subagent_config.py`): Domain name, description, and sub-agent definitions
- **Framework Code** (orchestration agents): Have `build_prompt()` / `build_schema()` methods that read from SubAgentRegistry

## Next Steps

1. **Implement Tools**: The tool functions in `tools/{key}_tools.py` are stubs.
   You need to implement the actual business logic.

2. **Test Your Application**:
   ```bash
   # Set USE_DEMO_OPSAGENT=false to use agent_factory
   USE_DEMO_OPSAGENT=false uv run uvicorn app.main:app --reload
   ```

3. **Optional**: Run the validation script:
   ```bash
   uv run python -c "
   from app.agent_factory.subagent_registry import get_registry
   r = get_registry()
   print('Domain:', r.domain_name)
   print('Description:', r.domain_description)
   print('Agent keys:', r.agent_keys)
   print('Descriptions:', r.generate_descriptions())
   "
   ```

Would you like me to help implement any of the tool functions?
```

## Phase 4: Tool Implementation (Optional)

If the user wants help implementing tools:

1. Ask for implementation details (API endpoints, business logic, data sources)
2. Generate working implementations for the tool functions
3. Replace the `NotImplementedError` stubs with actual code

## Important Notes

- Always use snake_case for keys and function names
- Always use PascalCase for class names
- Tool functions must return JSON strings
- Use `Annotated` type hints for parameters
- Follow the existing opsagent patterns (e.g., `servicenow_agent.py`)
- Infer parameter types from descriptions when not explicitly provided
- **Only generate `subagent_config.py`** - orchestration agents are framework code

## Example Session

```
User: /onboard

Claude: What domain does this assistant serve? Please provide:
1. **Domain name** (e.g., 'HR Assistant', 'IT Support')
2. **Description** (one sentence explaining what the assistant helps with)

User: HR Assistant - Helps employees manage leave, check payroll, and access benefits information

Claude: Now let's define your specialized agents. For each agent, I need:
- **Key**: Unique identifier (snake_case)
- **Name**: Display name
- **Description**: What this agent handles
- **Capabilities**: List of specific things it can do
- **Tools**: Functions it needs (name + what it does)

Please describe your first agent.

User: leave agent that handles vacation and leave requests. Can check leave balance, submit leave requests, cancel leave. Tools: get_leave_balance, submit_leave_request, cancel_leave_request

Claude: Got it! Do you have another agent to add? (yes/no)

User: yes, payroll agent for salary and compensation. Can view pay stubs, check bonus info. Tools: get_pay_stub, get_bonus_info

Claude: Do you have another agent to add? (yes/no)

User: no

Claude: ## Configuration Summary

**Domain**: HR Assistant - Helps employees manage leave, check payroll, and access benefits information

**Agents**:
1. **leave** (leave-agent)
   - Description: Handles vacation and leave requests
   - Capabilities: Check leave balance, Submit leave requests, Cancel leave
   - Tools: get_leave_balance, submit_leave_request, cancel_leave_request

2. **payroll** (payroll-agent)
   - Description: Handles salary and compensation queries
   - Capabilities: View pay stubs, Check bonus info
   - Tools: get_pay_stub, get_bonus_info

Does this look correct? (yes/no)

User: yes

Claude: [Generates files...]

## Files Generated
...
```
